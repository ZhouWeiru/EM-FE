'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _toArray2 = require('babel-runtime/helpers/toArray');

var _toArray3 = _interopRequireDefault(_toArray2);

exports.collect = collect;
exports.coverage = coverage;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _slash = require('slash');

var _slash2 = _interopRequireDefault(_slash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var flowBin = void 0;
// $FlowFixMe

/**
 * Run Flow and collect errors in JSON format
 *
 * Reference the following links for possible bug fixes and optimizations
 * https://github.com/facebook/nuclide/blob/master/pkg/nuclide-flow-rpc/lib/FlowRoot.js
 * https://github.com/ptmt/tryflow/blob/gh-pages/js/worker.js
 */


try {
  if (!process.env.FLOW_BIN) {
    // $FlowFixMe
    flowBin = require('flow-bin'); // eslint-disable-line global-require
  }
} catch (e) {
  /* eslint-disable */
  console.log();
  console.log('Oops! Something went wrong! :(');
  console.log();
  console.log('eslint-plugin-flowtype-errors could not find the package "flow-bin". This can happen for a couple different reasons.');
  console.log();
  console.log('1. If ESLint is installed globally, then make sure "flow-bin" is also installed globally.');
  console.log();
  console.log('2. If ESLint is installed locally, then it\'s likely that "flow-bin" is not installed correctly. Try reinstalling by running the following:');
  console.log();
  console.log('  npm i -D flow-bin@latest');
  console.log();
  process.exit(1);
  /* eslint-enable */
}

// Adapted from https://github.com/facebook/flow/blob/master/tsrc/flowResult.js

function mainLocOfError(error) {
  var operation = error.operation,
      message = error.message;

  return operation && operation.loc || message[0].loc;
}

/**
 * Wrap critical Flow exception into default Error json format
 */
function fatalError(stderr) {
  return {
    errors: [{
      message: [{
        path: '',
        line: 0,
        type: 'Comment',
        descr: stderr
      }]
    }]
  };
}

function _formatMessage(message, messages, root, path) {
  switch (message.type) {
    case 'Comment':
      return '' + message.descr;
    case 'Blame':
      {
        var see = message.path !== '' ? ' See ' + (path === message.path ? 'line ' + message.line : '.' + (0, _slash2.default)(message.path.replace(root, '')) + ':' + message.line) + '.' : '';
        return '\'' + message.descr + '\'.' + see;
      }
    default:
      return '\'' + message.descr + '\'.';
  }
}

function getFlowBin() {
  return process.env.FLOW_BIN || flowBin;
}

var didExecute = false;

function onExit(root) {
  if (!didExecute) {
    didExecute = true;
    process.on('exit', function () {
      return _child_process2.default.spawnSync(getFlowBin(), ['stop', root]);
    });
  }
}

function spawnFlow(mode, stdin, root, stopOnExit, filepath) {
  if (!stdin) {
    return '';
  }

  var child = _child_process2.default.spawnSync(getFlowBin(), [mode, '--json', '--root=' + root, filepath], {
    input: stdin,
    encoding: 'utf-8'
  });

  var stdout = child.stdout;

  if (!stdout) {
    //
    // This serves as a temporary HACK to prevent 32 bit OS's from failing. Flow does not
    // support 32 bit OS's at the moment.
    // This pretends as if there are no flow errors.
    //
    // Ideally, there would be a preinstall npm event to check if the user is on a 32 bit OS
    //
    return '';
  }

  if (stopOnExit) {
    onExit(root);
  }

  return stdout.toString();
}

function determineRuleType(description) {
  if (description.toLowerCase().includes('missing annotation')) {
    return 'missing-annotation';
  }

  return 'default';
}

function collect(stdin, root, stopOnExit, filepath) {
  var stdout = spawnFlow('check-contents', stdin, root, stopOnExit, filepath);

  if (!stdout) {
    return true;
  }

  var parsedJSONArray = void 0;

  try {
    parsedJSONArray = JSON.parse(stdout);
  } catch (e) {
    parsedJSONArray = fatalError('Flow returned invalid json');
  }

  var fullFilepath = _path2.default.resolve(root, filepath);

  // Loop through errors in the file
  var output = parsedJSONArray.errors
  // Temporarily hide the 'inconsistent use of library definitions' issue
  .filter(function (error) {
    var mainLoc = mainLocOfError(error);
    var mainFile = mainLoc && mainLoc.source;
    return mainFile && error.message[0].descr && !error.message[0].descr.includes('inconsistent use of') && _path2.default.resolve(root, mainFile) === fullFilepath;
  }).map(function (error) {
    var message = error.message,
        operation = error.operation;

    var _concat = [].concat(operation || [], message),
        _concat2 = (0, _toArray3.default)(_concat),
        firstMessage = _concat2[0],
        remainingMessages = _concat2.slice(1);

    var entireMessage = firstMessage.descr + ': ' + remainingMessages.reduce(function (previousMessage, currentMessage, index, messages) {
      return previousMessage + ' ' + _formatMessage(currentMessage, messages, root, firstMessage.path);
    }, '');

    var loc = firstMessage.loc;
    var finalMessage = entireMessage.replace(/\.$/, '');

    return (0, _extends3.default)({}, process.env.DEBUG_FLOWTYPE_ERRRORS === 'true' ? parsedJSONArray : {}, {
      type: determineRuleType(finalMessage),
      message: finalMessage,
      path: firstMessage.path,
      start: loc && loc.start.line,
      end: loc && loc.end.line,
      loc: firstMessage.loc
    });
  });

  return output;
}

function coverage(stdin, root, stopOnExit, filepath) {
  var stdout = spawnFlow('coverage', stdin, root, stopOnExit, filepath);

  if (!stdout) {
    return true;
  }

  var expressions = void 0;

  try {
    expressions = JSON.parse(stdout).expressions;
  } catch (e) {
    return {
      coveredCount: 0,
      uncoveredCount: 0
    };
  }

  return {
    coveredCount: expressions.covered_count,
    uncoveredCount: expressions.uncovered_count
  };
}